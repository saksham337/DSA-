https://leetcode.com/problems/sort-array-by-parity/
//classic two pointer started with 0 th index fix one pointer with condition and then swap with another just like fixing at the even index if the condition of even is satisfied then swap only 
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int n = nums.length;
        int j=0;
        for(int i=0;i<n;i++){
            if(nums[i] % 2 == 0){
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                j++;
            }
        }
        return nums;
    }
}
https://leetcode.com/problems/partition-array-according-to-given-pivot/description/
DNF - DEUTCH NATIONAL FLAG ALGORITHM WITH TWO POINTER VARIATION 
class Solution {
    public int[] pivotArray(int[] nums, int pivot) {
        int n = nums.length;
        int[] res = new int[n];
        int k=0;
        for(int i=0;i<n;i++){
            if(nums[i] < pivot){
                res[k] = nums[i];
                k++;
            }
        }
         for(int i=0;i<n;i++){
            if(nums[i] == pivot){
                res[k] = nums[i];
                k++;
            }
        }
         for(int i=0;i<n;i++){
            if(nums[i] > pivot){
                res[k] = nums[i];
                k++;
            }
        }
         return res;
        
    }
}


https://leetcode.com/problems/sort-array-by-parity-ii/description/
//Take two pointer one on odd index and another one on even index if they met condition then skip by +2 if not then swap with the jth pointer 
//here when the condition not met then swap only
class Solution {
    public int[] sortArrayByParityII(int[] nums) {
        int n  = nums.length;
        int i=0;
        int j=1;
        while(i < n && j < n){
            if(nums[i] % 2 == 0){
                i += 2;
            }else if(nums[j] % 2 == 1){
                j += 2;
            }else{
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i += 2;
                j += 2;
            }
        }
        return nums;
        
    }
}
https://leetcode.com/problems/rotate-array/description/
To do it in place extract k = k % n;
step 1 : revrse the entire array
step 2 : revrse till 0 to k-1
step 3 : reverse from k to n-1;
class Solution {
    private void reverse(int[] nums,int s,int e){
        while(s < e){
            int temp = nums[s];
            nums[s] = nums[e];
            nums[e] = temp;
            s++;
            e--;
        }

    }
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;
        reverse(nums,0,n-1);
        reverse(nums,0,k-1);
        reverse(nums,k,n-1);
        
    }
}

