https://leetcode.com/problems/sort-array-by-parity/
//classic two pointer started with 0 th index fix one pointer with condition and then swap with another just like fixing at the even index if the condition of even is satisfied then swap only 
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int n = nums.length;
        int j=0;
        for(int i=0;i<n;i++){
            if(nums[i] % 2 == 0){
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                j++;
            }
        }
        return nums;
    }
}
https://leetcode.com/problems/partition-array-according-to-given-pivot/description/
DNF - DEUTCH NATIONAL FLAG ALGORITHM WITH TWO POINTER VARIATION 
class Solution {
    public int[] pivotArray(int[] nums, int pivot) {
        int n = nums.length;
        int[] res = new int[n];
        int k=0;
        for(int i=0;i<n;i++){
            if(nums[i] < pivot){
                res[k] = nums[i];
                k++;
            }
        }
         for(int i=0;i<n;i++){
            if(nums[i] == pivot){
                res[k] = nums[i];
                k++;
            }
        }
         for(int i=0;i<n;i++){
            if(nums[i] > pivot){
                res[k] = nums[i];
                k++;
            }
        }
         return res;
        
    }
}


https://leetcode.com/problems/sort-array-by-parity-ii/description/
//Take two pointer one on odd index and another one on even index if they met condition then skip by +2 if not then swap with the jth pointer 
//here when the condition not met then swap only
class Solution {
    public int[] sortArrayByParityII(int[] nums) {
        int n  = nums.length;
        int i=0;
        int j=1;
        while(i < n && j < n){
            if(nums[i] % 2 == 0){
                i += 2;
            }else if(nums[j] % 2 == 1){
                j += 2;
            }else{
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i += 2;
                j += 2;
            }
        }
        return nums;
        
    }
}
https://leetcode.com/problems/3sum/description/
3sum :
STEP 1 : SORT THE ARRAY
STEP 2 : APPLY 2 POINTER FROM INDEX 1 WHILE KEEPING INDEX 0 CONSTANT 
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        if(nums == null || nums.length < 3){
            return new ArrayList<>();
        }      
        Set<List<Integer>> res = new HashSet<>();
        Arrays.sort(nums);

        for(int i=0;i<n-2;i++){
            if(i > 0 && nums[i] == nums[i-1]) continue;
            int left = i + 1;
            int right = n - 1;
            while(left < right){
                int sum  = nums[i] + nums[left] + nums[right];
                if(sum == 0){
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    left++;
                    right--;
                }else if(sum < 0){
                    left++;
                }else{
                    right--;
                }
            
           
            }
        }
        return new ArrayList<>(res);

        
    }
}
