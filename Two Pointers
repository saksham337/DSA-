https://leetcode.com/problems/sort-array-by-parity/
//classic two pointer started with 0 th index fix one pointer with condition and then swap with another just like fixing at the even index if the condition of even is satisfied then swap only 
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int n = nums.length;
        int j=0;
        for(int i=0;i<n;i++){
            if(nums[i] % 2 == 0){
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                j++;
            }
        }
        return nums;
    }
}
https://leetcode.com/problems/partition-array-according-to-given-pivot/description/
DNF - DEUTCH NATIONAL FLAG ALGORITHM WITH TWO POINTER VARIATION 
class Solution {
    public int[] pivotArray(int[] nums, int pivot) {
        int n = nums.length;
        int[] res = new int[n];
        int k=0;
        for(int i=0;i<n;i++){
            if(nums[i] < pivot){
                res[k] = nums[i];
                k++;
            }
        }
         for(int i=0;i<n;i++){
            if(nums[i] == pivot){
                res[k] = nums[i];
                k++;
            }
        }
         for(int i=0;i<n;i++){
            if(nums[i] > pivot){
                res[k] = nums[i];
                k++;
            }
        }
         return res;
        
    }
}


https://leetcode.com/problems/sort-array-by-parity-ii/description/
//Take two pointer one on odd index and another one on even index if they met condition then skip by +2 if not then swap with the jth pointer 
//here when the condition not met then swap only
class Solution {
    public int[] sortArrayByParityII(int[] nums) {
        int n  = nums.length;
        int i=0;
        int j=1;
        while(i < n && j < n){
            if(nums[i] % 2 == 0){
                i += 2;
            }else if(nums[j] % 2 == 1){
                j += 2;
            }else{
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i += 2;
                j += 2;
            }
        }
        return nums;
        
    }
}
https://leetcode.com/problems/3sum/description/
3sum :
STEP 1 : SORT THE ARRAY
STEP 2 : APPLY 2 POINTER FROM INDEX 1 WHILE KEEPING INDEX 0 CONSTANT 
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        if(nums == null || nums.length < 3){
            return new ArrayList<>();
        }      
        Set<List<Integer>> res = new HashSet<>();
        Arrays.sort(nums);

        for(int i=0;i<n-2;i++){
            if(i > 0 && nums[i] == nums[i-1]) continue;
            int left = i + 1;
            int right = n - 1;
            while(left < right){
                int sum  = nums[i] + nums[left] + nums[right];
                if(sum == 0){
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    left++;
                    right--;
                }else if(sum < 0){
                    left++;
                }else{
                    right--;
                }
            
           
            }
        }
        return new ArrayList<>(res);

        
    }
}
https://leetcode.com/problems/next-permutation/
To find the next permutation revrison do this three step on the following dry run 
arr = [2,1,5,4,3,0,0]
1) Try to find the longest prefix match just like rax and rbx  (Try to find the breakpoint from here you get the longest permutation after that )
2) Just try to finid the number grater than the current not that big not such that small just that big only
3) Reverse the array by placing them in sorted manner .

class Solution {
    private void reverse(int[] nums,int bp){
        int s = bp;
        int e = nums.length-1;
        while(s < e){
            int temp = nums[s];
            nums[s] = nums[e];
            nums[e] = temp;
            s++;
            e--;
        }

    }
    public void nextPermutation(int[] nums) {
      int n = nums.length; 
      //try to findd the breakpoint 
      int bp = 0;
      for(int i = n - 1 ; i > 0 ; i--){
        if(nums[i] > nums[i-1]){
            bp = i;
            break;
        }
      }
      //now find the element just greater than the bp to find the next permutation
       if(bp != 0){
        for(int i=n-1 ; i >= bp ; i--){
            if(nums[i] > nums[bp-1]){
                int temp = nums[i];
                nums[i] = nums[bp-1];
                nums[bp-1] = temp;
                break;
            }

        }
       }
       reverse(nums,bp);
       //revrese code
    }
}
https://leetcode.com/problems/reverse-words-in-a-string/
1)take two pointer and remove the trailing space.
2) Now append each word in stringbuilder when you got space just stop 
3) NOW push the appended word from the stringBuilder to Dequeue
Now join to get the reversed string Word.
class Solution {
    public String reverseWords(String s) {
        int l = 0;
        int r = s.length()-1;

        StringBuilder sb = new StringBuilder();
        Deque<String> dq = new ArrayDeque<>();

        while(l <= r && s.charAt(l) == ' ') l++;
        while(l <= r && s.charAt(r) == ' ') r--;

        while(l <= r){
            char ch = s.charAt(l);
            if(ch != ' '){
                sb.append(ch);
            }else if(sb.length() > 0){
                dq.offerFirst(sb.toString());
                sb.setLength(0);
            }
            l++;
        }
        if(sb.length() >0){
            dq.offerFirst(sb.toString());
        }
        return String.join(" ",dq);
        
    }
}
https://leetcode.com/problems/di-string-match/
TAKE TWO POINTER ONE START AT l = 0;and r = n;
IF ENCOUNTER I THEN PUT ITS INDEX IN POINTER AND INCREMENT IT AND IF ENCOUNTER D PUT IT IN ANS INDEX AND DECREAMENT THE POINTER .
class Solution {
    public int[] diStringMatch(String s) {
        int n = s.length();
        int[] ans = new int[n+1];
        int l = 0;
        int r = n;

      for(int i=0;i<n;i++){
        if(s.charAt(i) == 'I') {
            ans[i] = l++;
        }else{   
            ans[i] = r--;
        }
      }
      ans[n] = l;
      return ans;
        
    }
}
